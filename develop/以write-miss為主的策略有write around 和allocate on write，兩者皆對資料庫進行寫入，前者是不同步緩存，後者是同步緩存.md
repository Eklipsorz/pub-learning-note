## 描述

> ### Write-miss(就是你要更新的東西 不在緩存裡):

> 在這種情況下 客戶直接向DB發寫需求 在這種情況下 客戶直接向緩存發寫需求沒問題

> 更新了DB之後 這時DB就可以選擇同步(Synchronous) 或是不更新緩存 同步的更新叫做Allocate on write 不更新的叫做Write around

重點：
- write miss: 客戶端無法對緩存進行寫入，因素有：
	- 當客戶端想要新增東西時，因緩存空間不夠而無法寫入 
	- 當客戶端想要變更東西A時，該東西A卻不在緩存，而是在資料庫裡
- 解決write miss的方式：客戶端改去資料庫進行寫入，但就會面臨到資料庫是比緩存還要新這項問題，換言之，資料不一致
- 面對資料不一致問題有兩個常見方法：
	- write around：不同步緩存內容
	- allocate on write：同步緩存內容
### write around

> 寫的latency變小 仰賴Read-miss來更新緩存
> 
> 適合用在你寫完一個數據之後 下一次對於同一個數據的讀不會發生得太快 這樣就適合把latency花在讀

重點：
- write around 中的write是指緩存寫入，around原意為用以描述沒特定目標，在這裡的特定目標會是指不解決資料不一致問題，換言之，客戶端是直接寫入資料至資料庫或者在資料庫變更資料，並且不同步緩存上的資料。
> **often without a clear direction, purpose, or order**
- 單方面使用的話，會適合讀寫較少的場境，尤其是在寫較少的場景，則容易因為資料庫系統因處於硬碟而無法及時處理讓讀取請求能拿到最新最正確的值，至於為什麼少讀可以適用，這要看待於讀取的方式是否大多為專門讀修改後的資料，若是的話，就很適合。
- write around + read through 的場景：兩者都是從資料庫取出資料，而read through 則是將資料回寫至緩存，適用場景為寫入較少但讀取較多的場景，在這裡讀會是指專門讀取寫入後的資料，場景比如聊天訊息的讀取和寫入，讀取是讀取過去重複的內容較居多，寫入則是因為人類輸入的速度一般而言並不會如同電腦那樣快速那麼頻繁，所以可以適用於這場景
- 由於沒同步緩存，所以寫延遲會比allocate on write來得少

### allocate on write
> 一樣寫進兩個地方 如果下一次對於同一個數據的讀發生得很快 就適合這個

> 其實你仔細想想就知道 這其實跟Write-through是一樣的 都是緩存和DB都更新 差別只是原本緩存有沒有而已

重點：
- allocate on write：如同字面上的意思，每一次對資料庫進行寫入就把資料庫的寫入內容分配至緩存，這意味著每一次對資料庫進行寫入就同時也把同樣的資料內容分配至緩存，換言之，先寫入資料庫，接著在寫入緩存。
- allocate on write 和 write through 差異：
	- allocate on write 是資料庫有客戶端想要寫入的資料或者擁有能夠寫的地方，爾後再從資料庫同步緩存的資料
	- write through 是緩存有客戶端想要寫入的資料或者擁有能夠寫的地方，爾後再從緩存同步資料庫的資料

## 複習
#🧠 在有客戶端、緩存、資料庫的場景下：那麼write miss是指什麼 ->->-> `客戶端無法對緩存進行寫入，造成因素有當客戶端想要新增東西時，因緩存空間不夠而無法寫入、當客戶端想要變更東西A時，該東西A卻不在緩存，而是在資料庫裡`
<!--SR:!2022-07-18,31,248-->

#🧠 在有客戶端、緩存、資料庫的場景下：解決write miss的方式->->-> `客戶端改去資料庫進行寫入`
<!--SR:!2022-07-17,31,248-->


#🧠 在有客戶端、緩存、資料庫的場景下：解決write miss的方式改採去叫客戶端去對資料庫寫入的話，還會遇到什麼樣的問題 (提示：以緩存來比較新舊)->->-> `但就會面臨到資料庫是比緩存還要新這項問題，換言之，資料不一致`
<!--SR:!2022-07-04,21,228-->

#🧠 在有客戶端、緩存、資料庫的場景下：客戶端去對資料庫寫入的話，這樣資料庫是比緩存來得新，面對這樣問題有兩個常見方法，是哪兩個？->->-> `write around：不同步緩存內容、allocate on write：同步緩存內容`
<!--SR:!2022-07-20,32,248-->

#🧠 在有客戶端、緩存、資料庫的場景下：write around是什麼？->->-> `write around 中的write是指緩存寫入，around原意為用以描述沒特定目標，在這裡的特定目標會是指不解決資料不一致問題，換言之，客戶端是直接寫入資料至資料庫或者在資料庫變更資料，並且不同步緩存上的資料`
<!--SR:!2022-08-18,46,230-->

#🧠 在有客戶端、緩存、資料庫的場景下： write around的單方面場景是什麼？(提示讀寫效率好嗎) ->->-> `單方面使用的話，會適合讀寫較少的場境，尤其是在寫較少的場景`
<!--SR:!2022-07-23,23,210-->

#🧠 在有客戶端、緩存、資料庫的場景下： write around 為什麼適用於會適合讀寫較少的場境，尤其是在寫較少的場景？為什麼少讀也可以適用？ ->->-> `否則容易因為資料庫系統因處於硬碟而無法及時處理讓讀取請求能拿到最新最正確的值，至於為什麼少讀可以適用，這要看待於讀取的方式是否大多為專門讀修改後的資料，若是的話，就很適合`
<!--SR:!2022-07-12,17,243-->

#🧠 在有客戶端、緩存、資料庫的場景下： write around + read through 的場景 (提示：讀取、聊天) ->->-> `write around + read through 的場景：兩者都是從資料庫取出資料，而read through 則是將資料回寫至緩存，適用場景為寫入較少但讀取較多的場景，在這裡讀會是指專門讀取寫入後的資料，場景比如聊天訊息的讀取和寫入，讀取是讀取過去重複的內容較居多，寫入則是因為人類輸入的速度一般而言並不會如同電腦那樣快速那麼頻繁，所以可以適用於這場景`
<!--SR:!2022-07-12,17,243-->




#🧠 在有客戶端、緩存、資料庫的場景下：為啥客戶端會優先選擇緩存來存取資料，而不選擇處於硬碟的資料庫？ (請考量高負載的環境下)->->-> `因為硬碟本身的存取效率就沒比緩存/記憶體來得快速，這會使得在高負載的環境下可能因爲效率太低而無法及時處理讓讀寫請求而出現資料不一致的問題或者不如預期的樣子。`
<!--SR:!2022-07-19,28,226-->



#🧠 在有客戶端、緩存、資料庫的場景下：allocate on write是什麼？ ->->-> `如同字面上的意思，每一次對資料庫進行寫入就把資料庫的寫入內容分配至緩存，這意味著每一次對資料庫進行寫入就同時也把同樣的資料內容分配至緩存，換言之，先寫入資料庫，接著在寫入緩存。`
<!--SR:!2022-08-11,45,250-->


#🧠  在有客戶端、緩存、資料庫的場景下： allocate on write 和 write through 差異是什麼->->-> `allocate on write 是資料庫有客戶端想要寫入的資料或者擁有能夠寫的地方，爾後再從資料庫同步緩存的資料；write through 是緩存有客戶端想要寫入的資料或者擁有能夠寫的地方，爾後再從緩存同步資料庫的資料`
<!--SR:!2022-07-19,32,248-->

---
Status: #🌱 
Tags:
[[Caching]] - [[Redis]] - [[Database]]
Links:
[[以write-hit為主的write through和write back(write behind)這兩種寫入策略通常會為了一致性而與資料庫同步資料]]
[[cache hit為主的方法是從緩存存取資料但很容易被人忽略同步問題，cache miss為主的方法是從資料庫讀取資料但能選擇同步]]
[[inline Caching 是客戶端直接以cache為主要儲存系統的風格 ，Look-Aside Caching 則是先以cache來處理，再來以DB作處理的風格]]
References:
[[@cloud-leeCPUCacheYuanLiTanTao]]
[[@jyt0532HuanCunDuXieJiZhiJyt0532Blog]]
