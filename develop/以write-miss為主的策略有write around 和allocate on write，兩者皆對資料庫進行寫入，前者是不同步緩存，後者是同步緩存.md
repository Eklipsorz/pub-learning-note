## 描述

> ### Write-miss(就是你要更新的東西 不在緩存裡):

> 在這種情況下 客戶直接向DB發寫需求 在這種情況下 客戶直接向緩存發寫需求沒問題

> 更新了DB之後 這時DB就可以選擇同步(Synchronous) 或是不更新緩存 同步的更新叫做Allocate on write 不更新的叫做Write around

重點：
- write miss: 客戶端無法對緩存進行寫入，因素有：
	- 當客戶端想要變更東西A時，該東西A卻不在緩存，而是在資料庫裡
- 解決write miss的方式：客戶端改去資料庫進行寫入，但就會面臨到資料庫是比緩存還要新這項問題，換言之，資料不一致
- 面對資料不一致問題有兩個常見方法：
	- write around：不同步緩存內容
	- allocate on write：同步緩存內容

### write around

[[@jyt0532HuanCunDuXieJiZhiJyt0532Blog]]
> 寫的latency變小 仰賴Read-miss來更新緩存
> 
> 適合用在你寫完一個數據之後 下一次對於同一個數據的讀不會發生得太快 這樣就適合把latency花在讀

[[@cloud-leeCPUCacheYuanLiTanTao]]
> **Write No Allocate**
> 直接將寫入的訊號從 CPU Cache 繼續傳遞到主記憶體，並直接修改主記憶體中含有想要寫入的記憶體位置的 Block 的數值，但卻不會將此 Block 複製到 CPU Cache 中。

[[@wikidataCacheComputing2022]]
> _No-write allocate_ (also called _write-no-allocate_ or _write around_):
> data at the missed-write location is not loaded to cache, and is written directly to the backing store. In this approach, data is loaded into the cache on read misses only.


重點：
- write-no-allocate / No-write-allocate / write around，發生在write-miss才有的事件處理
- 這策略是當使用者未能在特定空間A中找到想要修改的資料，就直接寫入後備儲存空間B，最後並不會同步資料至特定空間A，策略會應用在客戶端場景、CPU場景：
	- 客戶端場景：使用者會是客戶端，特定空間A會是緩存，儲存空間B為處於硬碟的資料庫
	- CPU場景：使用者會是CPU，特定空間A會是離CPU最近的緩存空間，儲存空間B是離CPU較遠的記憶體
- 若要讓想要寫入的資料載入至緩存，就只有read miss的事件處理才有辦法

#### write around 名詞解釋
- write around 中的write是指緩存寫入，around原意為用以描述沒特定目標，在這裡的特定目標會是指不解決資料不一致問題，換言之，客戶端是直接寫入資料至資料庫或者在資料庫變更資料，並且不同步緩存上的資料。
> **often without a clear direction, purpose, or order**


#### write around 使用場景
- 單方面使用的話，會適合讀寫較少的場境，尤其是在寫較少的場景，則容易因為資料庫系統因處於硬碟而無法及時處理讓讀取請求能拿到最新最正確的值，至於為什麼少讀可以適用，這要看待於讀取的方式是否大多為專門讀修改後的資料，若是的話，就很適合。
- write around + read through 的場景：兩者都是從資料庫取出資料，而read through 則是將資料回寫至緩存，適用場景為寫入較少但讀取較多的場景，在這裡讀會是指專門讀取寫入後的資料，場景比如聊天訊息的讀取和寫入，讀取是讀取過去重複的內容較居多，寫入則是因為人類輸入的速度一般而言並不會如同電腦那樣快速那麼頻繁，所以可以適用於這場景



### allocate on write


[[@jyt0532HuanCunDuXieJiZhiJyt0532Blog]]
> 一樣寫進兩個地方 如果下一次對於同一個數據的讀發生得很快 就適合這個
> 其實你仔細想想就知道 這其實跟Write-through是一樣的 都是緩存和DB都更新 差別只是原本緩存有沒有而已


[[@cloud-leeCPUCacheYuanLiTanTao]]
>-   **Write Allocate**
    -   將主記憶體中含有想要寫入的記憶體位置的 Block 複製到 CPU Cache 中，並在修改 Cache 中該 Block 的數值後將該 Block 標記為 **Dirty Block**。

[[@wikidataCacheComputing2022]]
> _Write allocate_ (also called _fetch on write_): data at the missed-write location is loaded to cache, followed by a write-hit operation. In this approach, write misses are similar to read misses.

重點：
- write allocate / allocate on write，是當發生write miss時的事件處理
- 這策略如同字面上的意思，當使用者未能在特定空間A中找到想要修改的資料，特定空間A就會從後備儲存空間B取得想要修改的資料，並存放在緩存，最後讓使用者對緩存寫入，策略會應用在客戶端場景、CPU場景：
	- 客戶端場景：使用者會是客戶端，特定空間A會是緩存，儲存空間B為處於硬碟的資料庫
	- CPU場景：使用者會是CPU，特定空間A會是離CPU最近的緩存空間，儲存空間B會是離CPU較遠的記憶體
- 若要讓想要寫入的資料載入至緩存，目前策略就能處理



### allocate on write vs. write-no-allocate
兩者都發生在write miss的事件裡，並以客戶端為案例來說明：
1. 寫入資料方式：前者會寫入資料至主要空間和後備空間；後者就只是寫入資料至後備空間
2. 要寫入的資料何時能夠儲存在緩存：前者只要發生write-miss就會同步；後者是要發生read-miss才有機會


### allocate on write vs. write through
以客戶端為案例來說明：
1. 策略會實現在哪個事件：前者是發生在write miss；後者是發生在write hit
2. 寫入方式：前者是客戶端在緩存找不到要寫入的資料，緩存系統就從資料庫找到對應資料並寫入同樣資料分配給緩存，接著客戶端就對資料進行修改或寫入；後者是客戶端在緩存找到要寫入的資料，寫完之後就由緩存系統將資料回寫至資料庫



## 複習
#🧠 在有客戶端、緩存、資料庫的場景下：那麼write miss是指什麼 ->->-> `當客戶端想要變更東西A時，該東西A卻不在緩存，而是在資料庫裡`
<!--SR:!2023-10-09,252,242-->


#🧠 在有客戶端、緩存、資料庫的場景下：解決write miss的方式->->-> `客戶端改去資料庫進行寫入`
<!--SR:!2024-08-27,494,248-->


#🧠 在有客戶端、緩存、資料庫的場景下：解決write miss的方式改採去叫客戶端去對資料庫寫入的話，還會遇到什麼樣的問題 (提示：以緩存來比較新舊)->->-> `但就會面臨到資料庫是比緩存還要新這項問題，換言之，資料不一致`
<!--SR:!2023-08-14,249,228-->

#🧠 在有客戶端、緩存、資料庫的場景下：客戶端去對資料庫寫入的話，這樣資料庫是比緩存來得新，面對這樣問題有兩個常見方法，假定要以write-miss的情況下來解決，會是哪兩個？->->-> `write around：不同步緩存內容、allocate on write：同步緩存內容`
<!--SR:!2024-11-13,537,248-->

#🧠 在有客戶端、緩存、資料庫的場景下：客戶端去對資料庫寫入的話，這樣資料庫是比緩存來得新，面對這樣問題有兩個常見方法，不限定write-miss，會是哪兩個？->->-> `在write-miss的情況下將資料回寫 以及 在cache-miss的情況下將資料回寫`


#🧠 在有客戶端、緩存、資料庫的場景下：write around是什麼？->->-> `write around 中的write是指緩存寫入，around原意為用以描述沒特定目標，在這裡的特定目標會是指不解決資料不一致問題，換言之，客戶端是直接寫入資料至資料庫或者在資料庫變更資料，並且不同步緩存上的資料`
<!--SR:!2023-08-03,244,230-->

#🧠 write-no-allocate 是發生什麼才會觸發的策略？ ->->-> `write miss`
<!--SR:!2023-07-24,206,242-->


#🧠 write-no-allocate 策略原理是什麼？ ->->-> `這策略是當使用者未能在特定空間A中找到想要修改的資料，就直接寫入後備儲存空間B，最後並不會同步資料至特定空間A`
<!--SR:!2023-08-06,215,242-->

#🧠 在有客戶端、緩存、資料庫的場景下：write-no-allocate 策略原理是什麼？ ->->-> `這策略是當使用者未能在特定空間A中找到想要修改的資料，就直接寫入後備儲存空間B，最後並不會同步資料至特定空間A，策略會應用在客戶端場景、CPU場景： - 客戶端場景：使用者會是客戶端，特定空間A會是緩存，儲存空間B為處於硬碟的資料庫`
<!--SR:!2023-08-20,223,242-->

#🧠 在有CPU、緩存、記憶體的場景下：write-no-allocate 策略原理是什麼？->->-> `這策略是當使用者未能在特定空間A中找到想要修改的資料，就直接寫入後備儲存空間B，最後並不會同步資料至特定空間A，策略會應用在客戶端場景、CPU場景CPU場景：使用者會是CPU，特定空間A會是離CPU最近的緩存空間，儲存空間B是離CPU較遠的記憶體`
<!--SR:!2024-10-23,478,242-->

#🧠 在有客戶端、緩存、資料庫的場景下： write around的單方面場景是什麼？(提示讀寫效率好嗎) ->->-> `單方面使用的話，會適合讀寫較少的場境，尤其是在寫較少的場景`
<!--SR:!2023-06-27,50,170-->

#🧠 在有客戶端、緩存、資料庫的場景下： write around 為什麼適用於會適合讀寫較少的場境，尤其是在寫較少的場景？為什麼少讀也可以適用？ ->->-> `否則容易因為資料庫系統因處於硬碟而無法及時處理讓讀取請求能拿到最新最正確的值，至於為什麼少讀可以適用，這要看待於讀取的方式是否大多為專門讀修改後的資料，若是的話，就很適合`
<!--SR:!2023-08-26,259,243-->

#🧠 在有客戶端、緩存、資料庫的場景下： write around + read through 的場景 (提示：讀取、聊天) ->->-> `write around + read through 的場景：兩者都是從資料庫取出資料，而read through 則是將資料回寫至緩存，適用場景為寫入較少但讀取較多的場景，在這裡讀會是指專門讀取寫入後的資料，場景比如聊天訊息的讀取和寫入，讀取是讀取過去重複的內容較居多，寫入則是因為人類輸入的速度一般而言並不會如同電腦那樣快速那麼頻繁，所以可以適用於這場景`
<!--SR:!2023-08-15,252,243-->




#🧠 在有客戶端、緩存、資料庫的場景下：為啥客戶端會優先選擇緩存來存取資料，而不選擇處於硬碟的資料庫？ (請考量高負載的環境下)->->-> `因為硬碟本身的存取效率就沒比緩存/記憶體來得快速，這會使得在高負載的環境下可能因爲效率太低而無法及時處理讓讀寫請求而出現資料不一致的問題或者不如預期的樣子。`
<!--SR:!2023-11-28,301,226-->

#🧠 在有客戶端、緩存、資料庫的場景下：allocate on write是什麼？ ->->-> `這策略如同字面上的意思，當使用者未能在特定空間A中找到想要修改的資料，特定空間A就會從後備儲存空間B取得想要修改的資料，並存放在緩存，最後讓使用者對緩存寫入，策略會應用在客戶端場景、CPU場景：- 客戶端場景：使用者會是客戶端，特定空間A會是緩存，儲存空間B為處於硬碟的資料庫`
<!--SR:!2023-08-15,220,242-->

#🧠 在有CPU、緩存、記憶體的場景下：allocate on write是什麼？ ->->-> `這策略如同字面上的意思，當使用者未能在特定空間A中找到想要修改的資料，特定空間A就會從後備儲存空間B取得想要修改的資料，並存放在緩存，最後讓使用者對緩存寫入，策略會應用在客戶端場景、CPU場景：- CPU場景：使用者會是CPU，特定空間A會是離CPU最近的緩存空間，儲存空間B會是離CPU較遠的記憶體`
<!--SR:!2023-06-30,194,242-->

#🧠 allocate on write 策略是什麼？ ->->-> ` 這策略如同字面上的意思，當使用者未能在特定空間A中找到想要修改的資料，特定空間A就會從後備儲存空間B取得想要修改的資料，並存放在緩存，最後讓使用者對緩存寫入`
<!--SR:!2024-10-25,476,242-->

#🧠 allocate on write是當使用者未能在特定空間A中找到想要修改的資料所要做的事件處理，請問誰要負責從後備空間獲取想要修改的資料？ ->->-> `緩存系統`
<!--SR:!2023-10-01,247,242-->

#🧠 allocate on write策略下，如何讓想要寫入的資料載入至緩存？ ->->-> `若要讓想要寫入的資料載入至緩存，目前策略就能處理`
<!--SR:!2023-08-14,217,242-->

#🧠 write-no-allocate策略下，如何讓想要寫入的資料載入至緩存？ ->->-> `若要讓想要寫入的資料載入至緩存，就只有read miss的事件處理才有辦法`
<!--SR:!2023-07-20,205,242-->

#🧠 allocate on write vs. write-no-allocate 之間差異為何？以客戶端為案例來說明 ->->-> `1. 寫入資料方式：前者會寫入資料至主要空間和後備空間；後者就只是寫入資料至後備空間 2. 要寫入的資料何時能夠儲存在緩存：前者只要發生write-miss就會同步；後者是要發生cache-miss才有機會`
<!--SR:!2023-10-13,98,182-->


#🧠 allocate on write vs. write-no-allocate 共同點是什麼？ ->->-> `兩者都發生在write miss的事件裡`
<!--SR:!2023-10-31,264,242-->

#🧠 ### allocate on write vs. write through ，以客戶端為案例來說明->->-> `1. 策略會實現在哪個事件：前者是發生在write miss；後者是發生在write hit 2. 寫入方式：前者是客戶端在緩存找不到要寫入的資料，緩存系統就從資料庫找到對應資料並寫入同樣資料分配給緩存，接著客戶端就對資料進行修改或寫入；後者是客戶端在緩存找到要寫入的資料，寫完之後就由緩存系統將資料回寫至資料庫`
<!--SR:!2023-06-06,178,242-->

#🧠  在有客戶端、緩存、資料庫的場景下： allocate on write 和 write through 差異是什麼->->-> `allocate on write 是資料庫有客戶端想要寫入的資料或者擁有能夠寫的地方，爾後再從資料庫同步緩存的資料；write through 是緩存有客戶端想要寫入的資料或者擁有能夠寫的地方，爾後再從緩存同步資料庫的資料`
<!--SR:!2024-09-22,507,248-->

---
Status: #🌱 
Tags:
[[Caching]] - [[Redis]] - [[Database]]
Links:
[[以write-hit為主的write through和write back(write behind)這兩種寫入策略通常會為了一致性而與資料庫同步資料]]
[[cache hit為主的方法是從緩存存取資料但很容易被人忽略同步問題，cache miss為主的方法是從資料庫讀取資料但能選擇同步]]
[[inline Caching 是客戶端直接以cache為主要儲存系統的風格 ，Look-Aside Caching 則是先以cache來處理，再來以DB作處理的風格]]
References:
[[@wikidataCacheComputing2022]]
[[@cloud-leeCPUCacheYuanLiTanTao]]
[[@jyt0532HuanCunDuXieJiZhiJyt0532Blog]]
