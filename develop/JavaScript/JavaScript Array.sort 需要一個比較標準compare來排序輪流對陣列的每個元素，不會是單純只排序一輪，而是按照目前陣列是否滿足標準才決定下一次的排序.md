## 描述

[[@mdnArrayPrototypeSort]] 所描述：
> sort() 方法會原地（in place）對一個陣列的所有元素進行排序，並回傳此陣列

```
arr.sort([compareFunction])
```


> 如果 `compareFunction` 被應用，陣列元素們將根據比較函式之回傳值來排序。如果 `a` 和 `b` 為被比較之兩元素，則：

> -   若 `compareFunction(a, b)` 的回傳值小於 0，則會把 `a` 排在小於 `b` 之索引的位置，即 `a` 排在 `b` 前面。
> -   若 `compareFunction(a, b)` 回傳 0，則 `a` 與 `b` 皆不會改變彼此的順序，但會與其他全部的元素比較來排序。備註：ECMAscript 標準並不保證這個行為，因此不是所有瀏覽器（如 Mozilla 版本在 2003 以前）都遵守此行為。
> -   若 `compareFunction(a, b)` 的回傳值大於 0，則會把 `b` 排在小於 `a` 之索引的位置，即 `b` 排在 `a` 前面。
> 回傳值為
>  排序後的陣列。請注意此為原地（in place）進行排序過的陣列，並且不是原陣列的拷貝。


重點：
- sort 方法不透過額外記憶體來儲存排序子結果的排序方法，具體而言會輪流使用特定比較標準和比較算法來向每一次的比較結果重新排序，直到排序結果已經無法再透過標準和算法來調整結果就停止
- 比較標準會是以compareFunction的回傳值大小是否為比0大、比0小、等於0
- 每一輪都會是以整個陣列的每個元素來比較排序：挑選兩個元素並以比較標準來調整元素在目前陣列上的位置，也就是compareFunction(a,b)來呼叫對應比較標準：
	- 若比較標準回傳比0大：將b元素排在a元素前面 或者說 a元素排在b元素後面
	- 若比較標準回傳比0小：將a元素排在 b元素 前面
	- 若比較標準回傳等於0：不調整a和b兩者的位置
- 若要以排序標準下，將每個元素由大到小來排序 或者 由小到大來排序，則需要兩件事：
	- 定義標準能夠將a元素排在b元素後面、a元素排在b元素前面
	- 標準內容必須能夠使最後排序的結果由大到小或者由小到大來排序每個元素


### 案例比較
在這裡有兩種寫法，兩者皆為了要將陣列排序成特定標準下的由大至小的陣列結果，在這裏特定標準是以由建立日期的大至小為主。

寫法1：以元素a和元素b所擁有的日期解析值之間的差值來當作標準
- 若元素b較大的話，差值勢必會是大於0而將b元素排在a元素前面
- 若元素a較大的話，差值勢必會是小於0而將a元素排在b元素前面
- 若兩者相等的話，差值勢必會是0而不變動兩個元素的位置
- 比較標準內容是以單純的日期差值作為基礎

```
const compare = (a, b) => (Date.parse(b.createdAt) - Date.parse(a.createdAt))
products = results.sort(compare)
```

寫法2：以元素a和元素b兩者間的大小關係當作標準
- 若元素b較大的話，大小關係勢必會回傳1而將b元素排在a元素前面
- 若元素a較大的話，大小關係只會回傳0而不變動兩個元素的位置
- 若兩者相等的話，大小關係也只會回傳0而不變動兩個元素的位置
從上述描述來看，缺乏著定義如何將a元素排序在b元素之前的定義而無法正確將陣列的最後結果轉換成由大排至小的結果
```
const compare = (a, b) => (Date.parse(b.createdAt) >= Date.parse(a.createdAt))
products = results.sort(compare)
```



## 複習
#🧠 JavaScript Array.sort是什麼樣的排序方法？如何排序？(標準和算法) ->->-> `sort 方法不透過額外記憶體來儲存排序子結果的排序方法，具體而言會輪流使用特定比較標準和比較算法來向每一次的比較結果重新排序，直到排序結果已經無法再透過標準和算法來調整結果就停止`
<!--SR:!2023-11-16,108,228-->



#🧠 JavaScript Array.sort： 開發者明確定義誰先誰後的標準後，真能夠如開發者那樣會排序照特定標準下的由大至小或者由小至大嗎? 為什麼？->->-> `不一定，即使明確定義了標準函式回傳值是否大於0、小於0、等於0，還要看具體標準內容是什麼才能確定`
<!--SR:!2023-11-23,115,228-->

#🧠 JavaScript Array.sort 原生排序法會回傳另一個新陣列嗎 ->->-> `並不會，而是以原有陣列經過排序後的結果陣列`
<!--SR:!2025-02-01,557,248-->

#🧠 JavaScript Array.sort的比較標準compareFunction(a,b)若回傳值大於0，a和b如何擺放 ->->-> `a會放置於b之後`
<!--SR:!2023-11-10,102,230-->
#🧠 JavaScript Array.sort的比較標準compareFunction(a,b)若回傳值小於0，a和b如何擺放 ->->-> `a會放置於b之前`
<!--SR:!2024-03-31,249,208-->

#🧠 JavaScript Array.sort的比較標準compareFunction(a,b)若回傳值等於0，a和b如何擺放 ->->-> `維持不變`
<!--SR:!2024-08-14,457,248-->

#🧠 JavaScript Array.sort 所使用的排序標準具體會是什麼？會根據這個來調整元素的位置嗎？->->-> `以callback 或者函式物件為主，並挑目前陣列中的兩個元素來加入callback執行，最後依據回傳值是否為大於0、小於0、等於0來決定如何將挑到的兩個元素ab的位置進行調整`
<!--SR:!2024-06-23,328,228-->

#🧠 JavaScript Array.sort 所使用的排序標準compareFunction 具體會是以什麼樣的參數 ->->-> `從當前陣列結果中挑出兩個元素來放進compareFunction當參數`
<!--SR:!2023-11-19,111,228-->

#🧠 假使要實現將陣列排序成特定標準下的由大至小的陣列結果，在這裏特定標準是以由建立日期的大至小為主，且比較標準如下：- 若比較標準回傳比0大：將b元素排在a元素前面 或者說 a元素排在b元素後面 - 若比較標準回傳比0小：將a元素排在 b元素 前面 - 若比較標準回傳等於0：不調整a和b兩者的位置，請問程式碼寫上如下，能成功實現嗎？ 為什麼？![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1657548017/blog/algorithm/sort/javascript/correct-compare-function_d2akgm.png) ->->-> `能，具體定義以- 若元素b較大的話，差值勢必會是大於0而將b元素排在a元素前面 - 若元素a較大的話，差值勢必會是小於0而將a元素排在b元素前面 - 若兩者相等的話，差值勢必會是0而不變動兩個元素的位置 以及 比較標準內容是以單純的日期差值作為基礎，所以整體來說是可實現的`
<!--SR:!2025-02-16,566,248-->

#🧠 假使要實現將陣列排序成特定標準下的由大至小的陣列結果，在這裏特定標準是以由建立日期的大至小為主，且比較標準如下：- 若比較標準回傳比0大：將b元素排在a元素前面 或者說 a元素排在b元素後面 - 若比較標準回傳比0小：將a元素排在 b元素 前面 - 若比較標準回傳等於0：不調整a和b兩者的位置，請問程式碼寫上如下，能成功實現嗎？ 為什麼？ ![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1657548017/blog/algorithm/sort/javascript/incorrect-compare-function_amk9ta.png) ->->-> `不能，- 若元素b較大的話，大小關係勢必會回傳1而將b元素排在a元素前面 - 若元素a較大的話，大小關係只會回傳0而不變動兩個元素的位置 - 若兩者相等的話，大小關係也只會回傳0而不變動兩個元素的位置 從上述描述來看，缺乏著定義如何將a元素排序在b元素之前的定義而無法正確將陣列的最後結果轉換成由大排至小的結果`
<!--SR:!2025-02-18,568,248-->

---
Status: #🌱 
Tags:
[[JavaScript]]
Links:
References:
[[@mdnArrayPrototypeSort]]