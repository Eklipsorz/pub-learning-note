## 描述
[[@axinRedisWeiShiMoShiDanZhiXingXuGaoBingFaXiangYingKuaiQiTa]]所描述
> 1.redis是基於記憶體的，記憶體的讀寫速度非常快(純記憶體); 資料存在記憶體中，資料結構用HashMap，HashMap的優勢就是查詢和操作的時間複雜度都是O(1)。

> 2.redis是單執行緒的，省去了很多上下文切換執行緒的時間(避免執行緒切換和競態消耗)。


重點：
- redis 是以記憶體為主的NoSQL，每筆資料會用Key-value pairs來構成，為此會使用HashMap 來實現，進而讓存取對應單一pair的時間成本為O(1)
- redis 採用單執行緒作為主要處理(執行指令、redis本身內部處理)的主因是：
	- 不必要上鎖成本
	- 多執行緒下切換執行成本：[[執行緒切換(Thread switch) 是指N個執行緒實際無法從環境同時拿到N個實體核心執行時，就會輪流獲取核心來執行]]
	- 盡可能避免多個任務同時執行下之 race condition的發生(考量value會有更複雜的型別，比如hash、set)


### 官方答案

> ## 2.1.官方答案

> 因為Redis是基於記憶體的操作，CPU不是Redis的瓶頸，Redis的瓶頸最有可能是機器記憶體的大小或者網路頻寬。既然單執行緒容易實現，而且CPU不會成為瓶頸，那就順理成章地採用單執行緒的方案了。

> ## 2.2.效能指標

> 關於redis的效能，官方網站也有，普通筆記本輕鬆處理每秒幾十萬的請求。

> ## 2.3.詳細原因

> 1)不需要各種鎖的效能消耗

> Redis的資料結構並不全是簡單的Key-Value，還有list，hash等複雜的結構，這些結構有可能會進行很細粒度的操作，比如在很長的列表後面新增一個元素，在hash當中新增或者刪除一個物件。這些操作可能就需要加非常多的鎖，導致的結果是同步開銷大大增加。

> 總之，在單執行緒的情況下，就不用去考慮各種鎖的問題，不存在加鎖、釋放鎖操作，沒有因為可能出現死鎖而導致的效能消耗。

> 2)單執行緒多程序叢集方案

> 單執行緒的威力實際上非常強大，單核cpu效率也非常高，多執行緒自然是可以比單執行緒有更高的效能上限，但是在今天的計算環境中，即使是單機多執行緒的上限也往往不能滿足需要了，需要進一步摸索的是多伺服器叢集化的方案，這些方案中多執行緒的技術照樣是用不上的。

> 所以“單執行緒、多程序的叢集”不失為一個時髦的解決方案。

> 3)CPU消耗

> 採用單執行緒，避免了不必要的上下文切換和競爭條件，也不存在多程序或者多執行緒導致的切換而消耗 CPU。但是如果CPU成為Redis瓶頸，或者不想讓伺服器其他CUP核閒置，那怎麼辦？可以考慮多起幾個Redis程序，Redis是key-value資料庫，不是關係資料庫，資料之間沒有約束。只要客戶端分清哪些key放在哪個Redis程序上就可以了。

重點：
- Redis 官方說法的主因
	- 不必要執行緒切換
	- 盡可能透過減少多個執行緒同時執行來避免race condition、上鎖
- 一般而言，一個應用程式產出的多執行緒 vs 單執行緒
	-	擁有更高的效能上限，但實際上仍要考量實際能夠執行執行緒任務的實體核心數量以及採用何種技術(如是否會切換)，所以實際狀況，多執行緒並不會如同預期般得到很好的效能
	-	得考量著多執行緒是否會發生並行情況下的race condition而得花上CPU成本來處理上鎖和同步機制
- 由於Redis本身是單執行緒，而實體機有多個核心的話，所以最多會有一個核心來負責處理該執行緒，剩下閒置的核心該如何有效搭配Redis? 
	- 建立N個Redis 應用程式，來產出N個執行緒來執行，資料間由於沒約束，所以只需要標記哪些key是在哪個Redis 應用程式


## Redis單執行緒的優劣勢

> 3.1.單程序單執行緒優勢

> 1. 程式碼更清晰，處理邏輯更簡單。  
> 2. 不用去考慮各種鎖的問題，不存在加鎖、釋放鎖操作，沒有因為可能出現死鎖而導致的效能消耗。  
> 3. 不存在“多程序或者多執行緒導致的切換”而消耗CPU。

> 缺點：
> 1. 無法發揮多核CPU效能，不過可以通過在單機開多個Redis例項來完善。

重點：
- 優點1：開發的程式碼會因為單執行緒而變得較為簡單，不必考慮鎖、釋放、鎖死問題
- 優點2：Redis不用花上額外的成本去處理鎖、鎖釋放、鎖死、同步
- 優點3：Redis 不用因為實體機的實核心有限而讓多執行緒輪番分配給閒置的核心來處理
- 缺點1：可能無法發揮多核CPU效能，但可以在同個實體機上開多個Redis實例

## 複習
#🧠 redis 的key-value pairs 是用何種資料結構組成？為什麼(考慮特定資料的查詢) ->->-> `redis 是以記憶體為主的NoSQL，每筆資料會用Key-value pairs來構成，為此會使用HashMap 來實現，進而讓存取對應單一pair的時間成本為O(1)`
<!--SR:!2023-11-04,305,250-->

#🧠 redis 採用單執行緒作為主要處理(執行指令、redis本身內部處理)的主因是？(提示：鎖、切換、race) ->->-> `- 不必要上鎖成本 - 多執行緒下切換執行成本 - 盡可能減避免多個任務同時執行下之 race condition的發生(考量value會有更複雜的型別，比如hash、set)`
<!--SR:!2023-11-03,115,228-->


#🧠 一般而言，一個應用程式產出的多執行緒 vs 單執行緒會有什麼樣的預期(提示：多一些工人) ->->-> `擁有更高的效能上限`
<!--SR:!2024-06-25,450,250-->


#🧠 一般而言，一個應用程式產出的多執行緒 vs 單執行緒會有多執行緒擁有更高的效能上限，但實際上考量到實體CPU的話，會有什麼樣的問題(提示：我們有5個執行緒，但實體核心只有2個，該如何做啊？ 請說明是否輪流、資料同步)->->-> `實際上仍要考量實際能夠執行執行緒任務的實體核心數量以及採用何種技術(如是否會切換)，所以實際狀況，多執行緒並不會如同預期般得到很好的效能、得考量著多執行緒是否會發生多執行緒同時執行下的race condition而得花上CPU成本來處理上鎖和同步機制`
<!--SR:!2023-10-06,28,187-->


#🧠 由於Redis本身是單執行緒，而實體機有多個核心的話，所以最多會有一個核心來負責處理該執行緒，剩下閒置的核心該如何有效搭配Redis? (考慮哪個資料會是誰的？) ->->-> `建立N個Redis 應用程式，來產出N個執行緒來執行，資料間由於沒約束，所以只需要標記哪些key是在哪個Redis 應用程式`
<!--SR:!2024-01-11,326,230-->

#🧠 Redis單執行緒的優勢為？ (提示：開發成本？執行成本？ 資料同步？) ->->-> `- 優點1：開發的程式碼會因為單執行緒而變得較為簡單，不必考慮鎖、釋放、鎖死問題 - 優點2：Redis不用花上額外的成本去處理鎖、鎖釋放、鎖死、同步 - 優點3：Redis 不用因為實體機的實核心有限而讓多執行緒輪番分配給閒置的核心來處理`
<!--SR:!2023-10-13,57,170-->

#🧠 Redis單執行緒的劣勢 ->->-> `可能無法發揮多核CPU效能，但可以在同個實體機上開多個Redis實例`
<!--SR:!2023-12-25,338,250-->

---
Status: #🌱 
Tags:
[[Operating System]] - [[Database]]
Links:
[[執行緒切換(Thread switch) 是指N個執行緒實際無法從環境同時拿到N個實體核心執行時，就會輪流獲取核心來執行]]
[[race condition 是指多個程式模組以不受控制的執行順序來彼此競爭最後結果，使結果不如開發者所預期的結果]]
References:
[[@axinRedisWeiShiMoShiDanZhiXingXuGaoBingFaXiangYingKuaiQiTa]]