## 描述

> 缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。

![](https://s3.51cto.com/images/blog/202205/05235853_6273f43dc8d76425.png?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=)

重點：
- Hotspot Invalid是指某個時常被存取的key在緩存裡失效，若在這情況下出現大量請求來索要對應資料的話，全部請求會直接因為緩存找不到而導向至資料庫


### Hotspot Invalid 命名緣由
Hotspot 是指熱門地點，在這裡會是形容時常被存取的key，Invalid 是指無效的，合併在一起就是無效的熱門地點，在這裡會是指緩存上的時常被存取的key是無效的
> **a popular and exciting place**

### Hotspot Invalid 起因
如同問題名稱所述，起因源自於緩存中的時常被存取的key失效。

### Hotspot Invalid 解決辦法

> 解决方案：

> a)、在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降

> b)、热点数据缓存永远不过期。

重點：
- 緩存上的key失效後，可以通過互斥鎖或者隊列來控制多執行緒對於讀取資料庫資料並回寫至緩存，比如某個key就只允許一個執行緒去讀取資料庫資料和回寫至緩存，然後其他執行緒等待，但這些方法往往會阻塞其他執行緒，所以會使整體的吞吐量(成功被完成的請求數量)下降
- 將時常存取的key設定永遠不過期


#### 永不過期：物理上不過期 vs 邏輯上不過期 
> 永不过期实际包含两层意思：

> 物理不过期，针对热点key不设置过期时间

> 逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建

重點：設定永不過期的方式
- 實際在緩存系統不設定對應key的過期時間
- 將過期時間寫入對應key裡的value(該key對應多個value)，並且實現檢查機制來檢查該value是否過期，若過期就直接重建對key在緩存

## 複習
#🧠  Hotspot Invalid 命名緣由->->-> `Hotspot 是指熱門地點，在這裡會是形容時常被存取的key，Invalid 是指無效的，合併在一起就是無效的熱門地點，在這裡會是指緩存上的時常被存取的key是無效的`
<!--SR:!2022-08-30,55,250-->

#🧠 Hotspot Invalid 是什麼樣的問題 ->->-> `Hotspot Invalid是指某個時常被存取的key在緩存裡失效，若在這情況下出現大量請求來索要對應資料的話，全部請求會直接因為緩存找不到而導向至資料庫`
<!--SR:!2022-07-14,28,250-->

#🧠 Hotspot Invalid 起因 ->->-> `如同問題名稱所述，起因源自於緩存中的時常被存取的key失效。`
<!--SR:!2022-09-16,67,250-->

#🧠 Hotspot Invalid 解法是？ 若是要你用互斥鎖或者隊列強迫多執行緒只能乖乖排隊一次只執行一次，那解法會是？(提示：互斥鎖和先讀取再回寫)->->-> `緩存上的key失效後，可以通過互斥鎖或者隊列來控制多執行緒對於讀取資料庫資料並回寫至緩存，比如某個key就只允許一個執行緒去讀取資料庫資料和回寫至緩存，然後其他執行緒等待，但這些方法往往會阻塞其他執行緒，所以會使整體的吞吐量(成功被完成的請求數量)下降`
<!--SR:!2022-09-01,58,250-->

#🧠 Hotspot Invalid 解法是？若排除使用互斥鎖或隊列的話 ->->-> `將時常存取的key設定永遠不過期`
<!--SR:!2022-09-09,62,250-->

#🧠 Redis: 有哪些設定方式可以達成永不過期 (提示：邏輯上和Redis本身)>->-> `實際在緩存系統不設定對應key的過期時間、將過期時間寫入對應key裡的value(該key對應多個value)，並且實現檢查機制來檢查該value是否過期，若過期就直接重建對key在緩存`


---
Status: #🌱 
Tags:
[[Redis]] - [[Caching]]
Links:
[[Cache Avalanche 是指大量請求在cache上的大量key失效下而從cache被導向至處於硬碟的資料庫]]
[[Cache Penetration 是指請求因索取的東西原本就不存在資料庫而直接被導向至處於硬碟的資料庫]]
References:
[[@manbucoding2022NianRedisZuiXinMianShiTiDi8PianRedisHuanCunWenTiWx624642a80743cDeJiShuBoKe]]
[[@liuRedisKuaiQuXueBengJiChuan2021]]