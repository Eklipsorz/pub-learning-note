## 描述
引用[[@jyt0532HuanCunDuXieJiZhiJyt0532Blog]]所描述的：
>  ### Write-hit(就是你要更新的東西 也在緩存裡):
>  在這種情況下，客戶直接向緩存發寫需求沒問題，看是寫新資料或是更新舊資料都可以，更新了緩存之後 這時緩存就可以選擇同步(Synchronous) 或是非同步的(Asynchronous)更新DB 同步的更新叫做Write through 非同步的叫做Write back或是Write behind

重點：是以緩存(Cache/Memory)、資料庫(Disk)、客戶端(CPU)為主
- write hit 在這裡是指客戶端能夠在緩存寫入或者客戶端要更改的資料是在緩存
- 由於能夠在緩存進行寫入資料，這代表著緩存的資料是比資料庫的資料還新的，可選擇同步資料庫或者不同步，若不同步的話，只要當緩存崩潰時，整份資料將會永久性遺失；若同步的話，資料不至於會面臨到永久性遺失
- 不過通常會選擇同步，而通常會有兩個寫入兼同步策略：
	- write-through
	- write-back (behind)

### write-through 
引用[[@jyt0532HuanCunDuXieJiZhiJyt0532Blog]]所描述的：
> #### Write through優缺點
> 每次寫入都同時修改緩存跟DB，當然優點就是一致性得以滿足

> 缺點就是慢，因為要寫兩個地方(比沒有緩存還慢)

> 使用時機就是當你寫完一個數據後，下次讀會發生的很快很多次，這樣就適合把latency花在寫

write throguh：如同字面上的意思，客戶端會透過(穿過)緩存來新增東西A/變更處於資料庫的東西A內容，首先，當客戶端想要新增/編輯東西A時，會先去找緩存來進行，接著緩存上的同份資料會比資料庫上的資料還新，這時，緩存可選擇是否同步更新資料庫，理論上會選擇一同更新資料庫的資料。
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1653832279/blog/database/caching/Write-Through-Diagram_xacorf.png)

流程會是如下：
- 步驟一、客戶端想要新增/變更東西A，就向緩存裡找，結果找到並且成功新增/變更
- 步驟二、緩存想同步東西A至資料庫，所以緩存對資料庫發送新增/變更東西A的請求，
- 步驟三、資料庫成功同步後，緩存就告知客戶端已完成寫入
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1653832279/blog/database/caching/Write-Through-Steps_atyh3p.png)

#### 缺點
1. 由於新增/變更東西A的地方會是緩存和資料庫，所以會比沒有緩存的情況下還要更慢
#### 優點
1. 由於會連同資料庫和緩存一起同步，所以資料上的一致性問題可以減緩

### write-back (write-behind)
引用[[@jyt0532HuanCunDuXieJiZhiJyt0532Blog]]所描述的：
> 寫入緩存後就回傳給客戶 我之後**有空**的時候再慢慢修改DB 保証了write lantency的下降

> Note: 通常大家都很忙 沒什麼空 但是修改DB的死線是cache的那個entry要被evict的時候 最起碼在那個時候 你要寫回DB 在那之前的cache hit都可以直接回傳

> 所以實作起來 每一個緩存的entry都要有一個dirty bit. 只要你修改過這個值 dirty bit就要設成true 等到evict的時候 如果dirty bit是true就要更新DB

> 但缺點也很明顯 通常DB的recover機制非常健全但緩存沒有太多recover機制 要是你的cache當機或是跳電 你的某些只寫在緩存而不在DB的資料就永遠消失了

> 使用時機就是讀寫發生的很平均 Write back機制讓讀寫都不會latency太高 但是要小心Crash的問題

write back：如同字面上的意思，要同步資料的話，不會立刻同步，而是挑時間點同步，首先，當客戶端想要新增/變更東西A時，就會優先去緩存進行，若可以在緩存進行，隨後執行完，緩存內容就會比資料庫還要新，這時客戶端可選擇是否同步東西A到資料庫，若要同步的話，會挑一個時間點來同步，通常是比較系統都有空的時間來同步

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1653840575/blog/database/caching/Write-Back-Steps_xngliy.png)
流程：
-  步驟一、當客戶端想要新增/變更東西A時，就會優先去緩存
-  步驟二、客戶端挑時間點去同步東西A至資料庫

#### 標記哪些緩存資料要同步至資料庫
通常若要實作write-back的資料庫同步，會先替每一個在緩存的資料增加dirty bit，若有經過新增或者變更，就設dirty bit為true，來告知系統哪些資料是需要同步的；若沒有經過新增或變更，就維持dirty bit為false


#### 何時同步資料庫
另一個問題是何時同步，通常最晚會是在緩存資料要被清除或者驅逐出去之前就把資料同步至資料庫，否則就是挑選流量較小、負載較小的時候。

#### 缺點
1. 由於最新資料會集中在緩存，若在同步資料庫之前發生當機、跳電，那些存在緩存的資料就會消失，除非有做好緩存上的資料復原機制
2. 資料庫和緩存之間的一致性和完整性很差。

#### 優點
緩存拿到的資料都會是最新的，不會因為資料庫同步問題而使得客戶端拿到的資料是舊的。

### note
引用[[@cloud-leeCPUCacheYuanLiTanTao]]所描述的 write hit & write miss 概念：
> ### [](https://hackmd.io/@drwQtdGASN2n-vt_4poKnw/H1U6NgK3Z?type=view#44-When-CPU-Wants-to-Write "44-When-CPU-Wants-to-Write")4.4 When CPU Wants to Write
>-   如果在 Cache 裡可以找到想要寫入的資料位置 -> **Write Hit**
>-   相反的，如果找不到 -> **Write Miss**


write hit 和 write miss 原理源自於CPU能否成功對緩存進行寫入(新增或變更)：
- write 指的是緩存寫入，hit和write則是表示命中或者落空，合併起來就是分別為緩存寫入命中(成功)和緩存寫入落空(失敗)，在這裡的緩存寫入是指在緩存新增特定東西或者在緩存中的已存在東西進行變更
- 若CPU能夠成功對緩存進行寫入，就表示緩存寫入命中(成功)
- 若CPU能夠無法對緩存進行寫入，就表示緩存寫入落空(失敗)
- 另外設計者也預期系統能夠優先從最近最快速的儲存空間-緩存來寫入資料，若無法做到，就預期落空；若做到，就預期命中


在這裡能夠讓CPU無法成功對緩存進行寫入，通常有2個常見因素：
- 緩存沒空間可以寫入
- 要變更的東西A已不在緩存了，CPU得跑到東西A的所在來變更其內容

## 複習
#🧠 write hit 和 write miss對於設計者的預期是什麼？ ->->-> `另外設計者也預期系統能夠優先從最近最快速的儲存空間-緩存來寫入資料，若無法做到，就預期落空；若做到，就預期命中`
<!--SR:!2022-10-07,77,249-->


#🧠 以CPU、緩存、記憶體而言，write hit 和 write miss 的 hit 和 miss 是指？ ->->-> `若CPU能夠成功對緩存進行寫入，就表示緩存寫入命中(成功)；若CPU無法對緩存進行寫入，就表示緩存寫入落空(失敗)`
<!--SR:!2022-08-06,40,249-->

#🧠 以客戶端、緩存、資料庫而言，write hit 和 write miss 的 hit 和 miss 是指？ ->->-> `若客戶端能夠成功對緩存進行寫入，就表示緩存寫入命中(成功)；若客戶端無法對緩存進行寫入，就表示緩存寫入落空(失敗)`
<!--SR:!2022-08-02,37,249-->


#🧠 write hit 和 write miss 命名原理源自於？請盡可能考量到空間是否還能夠存->->-> `write hit 和 write miss 原理源自於CPU能否成功對緩存進行寫入(新增或變更)，write 指的是緩存寫入，hit和write則是表示命中或者落空，合併起來就是分別為緩存寫入命中(成功)和緩存寫入落空(失敗)，在這裡的緩存寫入是指在緩存新增特定東西或者在緩存中的已存在東西進行變更，若CPU能夠成功對緩存進行寫入，就表示緩存寫入命中(成功)；若CPU能夠無法對緩存進行寫入，就表示緩存寫入落空(失敗)`
<!--SR:!2022-09-01,58,250-->

#🧠 在這裡能夠讓CPU無法成功對緩存進行寫入，通常有哪兩個常見因素？->->-> `緩存沒空間可以寫入、要變更的東西A已不在緩存了，CPU得跑到東西A的所在來變更其內容`
<!--SR:!2022-07-29,38,249-->

#🧠 客戶端、資料庫、緩存間的寫入兼同步策略： write-through是什麼？->->-> `同字面上的意思，客戶端會透過(穿過)緩存來新增東西A/變更處於資料庫的東西A內容，首先，當客戶端想要新增/編輯東西A時，會先去找緩存來進行，接著緩存上的同份資料會比資料庫上的資料還新，這時，緩存可選擇是否同步更新資料庫，理論上會選擇一同更新資料庫的資料`
<!--SR:!2022-09-10,65,250-->

#🧠 客戶端、資料庫、緩存間的寫入兼同步策略：請用下圖來說明write-through流程![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1653832279/blog/database/caching/Write-Through-Steps_atyh3p.png) ->->-> `- 步驟一、客戶端想要新增/變更東西A，就向緩存裡找，結果找到並且成功新增/變更、步驟二、緩存想同步東西A至資料庫，所以緩存對資料庫發送新增/變更東西A的請求、步驟三、資料庫成功同步後，緩存就告知客戶端已完成寫入`
<!--SR:!2022-09-20,72,250-->

#🧠 客戶端、資料庫、緩存間的寫入兼同步策略： write-through的優缺點->->-> `缺點是由於新增/變更東西A的地方會是緩存和資料庫，所以會比沒有緩存的情況下還要更慢、優點是1. 由於會連同資料庫和緩存一起同步，所以資料上的一致性問題可以減緩`
<!--SR:!2022-08-05,33,248-->


#🧠  客戶端、資料庫、緩存間的寫入兼同步策略： write-back(behind)是什麼？ ->->-> `write back：如同字面上的意思，要同步資料的話，不會立刻同步，而是挑時間點同步，首先，當客戶端想要新增/變更東西A時，就會優先去緩存進行，若可以在緩存進行，隨後執行完，緩存內容就會比資料庫還要新，這時客戶端可選擇是否同步東西A到資料庫，若要同步的話，會挑一個時間點來同步，通常是比較系統都有空的時間來同步`
<!--SR:!2022-09-11,66,250-->

#🧠 客戶端、資料庫、緩存間的寫入兼同步策略：請用下圖來說明write-back(behind)流程 ![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1653840575/blog/database/caching/Write-Back-Steps_xngliy.png) ->->-> `步驟一、當客戶端想要新增/變更東西A時，就會優先去緩存、步驟二、客戶端挑時間點去同步東西A至資料庫`
<!--SR:!2022-10-31,95,249-->

#🧠 客戶端、資料庫、緩存間的 write-back(behind)：如何標記哪些緩存資料是要同步至資料庫 ->->-> `通常若要實作write-back的資料庫同步，會先替每一個在緩存的資料增加dirty bit，若有經過新增或者變更，就設dirty bit為true，來告知系統哪些資料是需要同步的；若沒有經過新增或變更，就維持dirty bit為false`
<!--SR:!2022-09-12,66,250-->

#🧠 客戶端、資料庫、緩存間的 write-back(behind)：何時同步資料至資料庫 : ->->-> `通常最晚會是在緩存資料要被清除或者驅逐出去之前就把資料同步至資料庫，否則就是挑選流量較小、負載較小的時候。`
<!--SR:!2022-08-12,24,190-->

#🧠 客戶端、資料庫、緩存間的寫入兼同步策略： write-back的優缺點 ->->-> `缺點是由於最新資料會集中在緩存，若在同步資料庫之前發生當機、跳電，那些存在緩存的資料就會消失，除非有做好緩存上的資料復原機制、一致性、完整性很差。優點是緩存拿到的資料都會是最新的，不會因為資料庫同步問題而使得客戶端拿到的資料是舊的。`
<!--SR:!2022-08-05,10,210-->

---
Status: #🌱 
Tags:
[[Caching]] - [[Redis]] - [[Database]]
Links:
[[以write-miss為主的策略有write around 和allocate on write，兩者皆對資料庫進行寫入，前者是不同步緩存，後者是同步緩存]]
[[cache hit為主的方法是從緩存存取資料但很容易被人忽略同步問題，cache miss為主的方法是從資料庫讀取資料但能選擇同步]]
[[inline Caching 是客戶端直接以cache為主要儲存系統的風格 ，Look-Aside Caching 則是先以cache來處理，再來以DB作處理的風格]]
References:
[[@cloud-leeCPUCacheYuanLiTanTao]]
[[@jyt0532HuanCunDuXieJiZhiJyt0532Blog]]
