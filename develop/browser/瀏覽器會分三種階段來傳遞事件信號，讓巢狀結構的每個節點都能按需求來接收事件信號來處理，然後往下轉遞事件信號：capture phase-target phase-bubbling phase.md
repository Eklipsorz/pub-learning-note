## 描述



### Event Flow

如果使用者對著巢狀結構下的子元件來進行互動時，比如類似於程式碼中的元素3(element3)，那麼瀏覽器該如何判定這次的互動/事件是屬於哪個元素呢？瀏覽器大可直接根據事件是源自於哪裡來將事件歸類於element3，並且由它的事件處理來處理

```
<element1>
	<element2>
		<element3>content</element3>
	</element2>
</element1>
```

  

可由於是巢狀關係(如下圖)，元素3(element3)被元素2(element2)所包含著，而元素2(element2)被元素1(element1)包含著，嚴格來說，當使用者對元素3(element3)做互動，同樣地也對著另外兩個元素進行互動，更甚至說包含這些元素的元素(比如body)也跟著互動。


![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1630587482/blog/event/threeElements_lohr6c.png)

  
  

這時，瀏覽器可以有幾種選擇去決定事件是屬於哪個元件，第一種選擇是按照之前的規則，直接將事件歸類於元素3(element3)並發送信號給元素3，並對元素3的EventListener來找尋對應的事件處理，另外一種則是使用事件流(event flow)將訊號傳遞給每個包含元素3的元素，並試著對這些元素的EventListener找尋對應的事件處理，只是傳遞方向又可以細分兩種，一種是從最外圍的元素1開始往內傳遞的事件捕獲(event capture)，也就是信號會先傳遞至元素1，接著在傳遞元素2，最後傳遞元素3，另外一種則是從元素3往外傳遞信號的事件冒泡(Event bubbling)，也就是信號會先傳遞至元素3(發生事件的來源處)，接著在傳遞至元素2，最後傳遞元素1。

  

不過實際上來說，瀏覽器傳遞信號會一次分三種階段來傳遞信號，當對一個目標元件X產生互動時，第一個階段會先從包含元件X的最外面元件到內部元件來傳遞信號的捕獲階段(Capturing Phase)，第二個階段為從目標元件X的父元件傳遞信號至目標元件X的目標階段(Target Phase)，最後一個階段會先從目標元件X往外傳遞信號的冒泡階段(Bubbling Phase)，當使用者對某個元件X進行互動時，瀏覽器會先透過第一個階段來傳遞信號，接著就是第二個階段：將信號傳遞至實際發生事件/互動的元件X，最後就是第三個階段傳遞信號。

  

![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636879992/blog/event/currentPropagationPath_rj9x5j.png)


### 重點



- event flow被提出的原因是
	- 巢狀結構中的每個parent節點會由child節點所構成
	- 基於第一點，當巢狀結構中的任一節點X發生事件時，那麼事件要歸屬於哪個元件的事件？是包含節點X的parent節點？還是節點X?
- event flow 概念為當元件X發生事件時，會在包含元件X的巢狀結構中依序將事件信號發送至各個元件。
- 具體實現為當元件X發生事件時，瀏覽器會分三種階段來傳遞事件信號，讓巢狀結構的每個節點都能按需求來接收事件信號來處理，然後往下轉遞事件信號：
	- 有節點會是接收並處理就會讓該節點處理事件，處理完就轉遞信號至下一個節點；沒節點會接收來處理，就直接跳過並轉遞至下一個節點
	- Capture phase (第一個階段)：從window節點往下轉遞信號至下面它所包含的child節點，直到轉遞至包含節點X的parent節點，就換下一個階段
	- Target phase (第二個階段)：從包含節點X的parent節點轉遞事件信號至目標節點(X)，接著就換下一個階段
	- Bubbling phase (第三個階段)：從節點X往上轉遞parent節點，接著再往包含parent節點的parent元件轉遞，一直轉遞到window節點就停下轉遞
![](https://res.cloudinary.com/dqfxgtyoi/image/upload/v1636879992/blog/event/currentPropagationPath_rj9x5j.png)


## 複習

#🧠 網頁：event flow 被提出的原因是什麼？ ->->-> `	- 巢狀結構中的每個parent節點會由child節點所構成 - 基於第一點，當巢狀結構中的任一節點X發生事件時，那麼事件要歸屬於哪個元件的事件？是包含節點X的parent節點？還是節點X?`
<!--SR:!2024-10-01,413,250-->

#🧠 網頁：event flow 概念是什麼？->->-> `為當元件X發生事件時，會在包含元件X的巢狀結構中依序將事件信號發送至各個元件。`
<!--SR:!2023-09-21,193,250-->

#🧠 event flow 概念為當元件X發生事件時，會在包含元件X的巢狀結構中依序將事件信號發送至各個元件，具體瀏覽器的實現會是什麼？想接收信號的節點會如何處理？ ->->-> `具體實現為當元件X發生事件時，瀏覽器會分三種階段來傳遞事件信號，讓巢狀結構的每個節點都能按需求來接收事件信號來處理，然後往下轉遞事件信號，過程中，有節點會是接收並處理就會讓該節點處理事件，處理完就轉遞信號至下一個節點；沒節點會接收來處理，就直接跳過並轉遞至下一個節點`
<!--SR:!2023-09-13,188,250-->

#🧠 event flow 概念為當元件X發生事件時，會在包含元件X的巢狀結構中依序將事件信號發送至各個元件，具體瀏覽器的實現主要是讓巢狀結構的每個節點都能按需求來接收事件信號來處理，那麼接收到的節點和不想接收的節點會如何面對信號和處理？ ->->-> `有節點會是接收並處理就會讓該節點處理事件，處理完就轉遞信號至下一個節點；沒節點會接收來處理，就直接跳過並轉遞至下一個節點`
<!--SR:!2024-12-14,468,250-->

#🧠 瀏覽器的event flow中，會有三個階段，請問會是什麼？ ->->-> `Capture phase、target phase、bubbling phase`
<!--SR:!2023-09-25,195,250-->

#🧠 瀏覽器的event flow中，會有三個階段，請問執行順序會是什麼？->->-> `Capture phase->target phase->bubbling phase`
<!--SR:!2023-10-14,207,250-->

#🧠 瀏覽器的event flow中，會有三個階段，這三個階段是擇一才做，還是一起做？ ->->-> `會輪流做`
<!--SR:!2024-12-08,458,250-->

#🧠  瀏覽器的event flow中，會有三個階段，具體說明->->-> `	- Capture phase (第一個階段)：從window節點往下轉遞信號至下面它所包含的child節點，直到轉遞至包含節點X的parent節點，就換下一個階段 - Target phase (第二個階段)：從包含節點X的parent節點轉遞事件信號至目標節點(X)，接著就換下一個階段 - Bubbling phase (第三個階段)：從節點X往上轉遞parent節點，接著再往包含parent節點的parent元件轉遞，一直轉遞到window節點就停下轉遞`
<!--SR:!2023-09-27,196,250-->

#🧠 瀏覽器的event flow中，會有三個階段，具體說明capture phase ->->-> `從window節點往下轉遞信號至下面它所包含的child節點，直到轉遞至包含節點X的parent節點，就換下一個階段`
<!--SR:!2023-10-07,203,250-->

#🧠 瀏覽器的event flow中，會有三個階段，具體說明target phase ->->-> `從包含節點X的parent節點轉遞事件信號至目標節點(X)，接著就換下一個階段`
<!--SR:!2023-09-16,190,250-->

#🧠 瀏覽器的event flow中，會有三個階段，具體說明bubbling phase->->-> `從節點X往上轉遞parent節點，接著再往包含parent節點的parent元件轉遞，一直轉遞到window節點就停下轉遞`
<!--SR:!2023-11-25,87,230-->




---
Status: #🌱 
Tags:
[[HTML]] - [[JavaScript]]
Links:
[[在event flow中，每個接收到事件訊號的DOM節點會先接收信號並做對應事件處理完畢之後才會發送信號至下一個DOM節點]]
[[arrow function 在implicit binding、explicit binding、addEventListener上的案例]]
References: