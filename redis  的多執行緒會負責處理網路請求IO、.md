## 描述
[[@MianShiGuanWenRedisShiDanZhiXingXuHuanShiDuoZhiXingXu]]所描述：

### 版本3.0

> Redis 3.0 版本後，主程式中除了主執行緒處理網路 IO 和命令操作外，還有 3 個輔助 BIO 執行緒。這 3 個 BIO 執行緒分別負責處理，檔案關閉、AOF 緩衝資料重新整理到磁碟，以及清理物件這三個任務佇列，從而避免這些任務對主 IO 執行緒的影響。
> Redis 在啟動時，會同時啟動這三個 BIO 執行緒，但是 BIO 執行緒只有在需要執行相關型別後臺任務時才會喚醒，其他時間會休眠等待任務。

![](https://i.iter01.com/images/ad6688b840c91cb804f3c2a21289d2e581484efc2c9d9c421bb9323a8299831f.png)

重點：
- 在Redis 3.x版本中，主執行緒負責處理網路請求IO、處理指令操作
- 除了主執行緒以外，還有三個輔助用的BIO 執行緒來負責以下業務，這些執行緒只有在需要時才會被喚醒，平時都會保持睡眠
	- fsync 執行緒：AOF 緩衝資料重新整理到磁碟
	- close執行緒：檔案關閉
	- 清理回收執行緒：清理物件
- fsync 執行緒、close執行緒、清理回收執行緒是Background I/O (BIO) ，會於背景下執行。


### 版本6.0

> 多執行緒是 Redis6.0 推出的一個新特性。正如上面所說 Redis 是核心執行緒負責網路 IO ，命令處理以及寫資料到緩衝，而隨著網路硬體的效能提升，單個主執行緒處理⽹絡請求的速度跟不上底層⽹絡硬體的速度，導致網路 IO 的處理成為了 Redis 的效能瓶頸。

> 而 Redis6.0 就是從單執行緒處理網路請求到多執行緒處理，通過多個 IO 執行緒並⾏處理網路操作提升例項的整體處理效能。需要注意的是對於讀寫命令，Redis 仍然使⽤單執行緒來處理，這是因為繼續使⽤單執行緒執行命令操作，就不⽤為了保證 Lua 指令碼、事務的原⼦性，額外開發多執行緒互斥機制了。


![](https://i.iter01.com/images/366286b2a68f20c755c2692895d9ff3a58719c78e75a4adf43ae2be2f6841850.png)


> 全部流程分為以下 4 階段：

> **階段一：服務端和客⼾端建立 Socket 連線，並分配處理執行緒**

> 當有客⼾端請求和例項建立 Socket 連線時，主執行緒會建立和客戶端的連線，並把 Socket 放入全域性等待佇列中。然後主執行緒通過輪詢方法把 Socket 連線分配給 IO 執行緒。

> **階段二：IO 執行緒讀取並解析請求**

> 主執行緒把 Socket 分配給 IO 執行緒後，會進⼊阻塞狀態等待 IO 執行緒完成客戶端請求讀取和解析。

> **階段三：主執行緒執⾏請求操作**

> IO 執行緒解析完請求後，主執行緒以單執行緒的⽅式執⾏這些命令操作。

> **階段四：IO 執行緒回寫 Socket 和主執行緒清空全域性隊**

> 主執行緒執行完請求操作後，會把需要返回的結果寫入緩衝區。然後，主執行緒會阻塞等待 IO 執行緒把這些結果回寫到 Socket 中，並返回給客戶端。等到 IO 執行緒回寫 Socket 完畢，主執行緒會清空全域性佇列，等待客戶端的後續請求。

重點：


## 複習
#🧠 Question :: ->->-> ``

---
Status: 
Tags:
Links:
References:
[[@MianShiGuanWenRedisShiDanZhiXingXuHuanShiDuoZhiXingXu]]
