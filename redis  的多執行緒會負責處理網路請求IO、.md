## 描述
[[@MianShiGuanWenRedisShiDanZhiXingXuHuanShiDuoZhiXingXu]]所描述：

### 版本3.0

> Redis 3.0 版本後，主程式中除了主執行緒處理網路 IO 和命令操作外，還有 3 個輔助 BIO 執行緒。這 3 個 BIO 執行緒分別負責處理，檔案關閉、AOF 緩衝資料重新整理到磁碟，以及清理物件這三個任務佇列，從而避免這些任務對主 IO 執行緒的影響。
> Redis 在啟動時，會同時啟動這三個 BIO 執行緒，但是 BIO 執行緒只有在需要執行相關型別後臺任務時才會喚醒，其他時間會休眠等待任務。

![](https://i.iter01.com/images/ad6688b840c91cb804f3c2a21289d2e581484efc2c9d9c421bb9323a8299831f.png)

重點：
- 在Redis 3.x版本中，主執行緒負責處理網路請求IO、處理指令操作
- 除了主執行緒以外，還有三個輔助用的BIO 執行緒來負責以下業務，這些執行緒只有在需要時才會被喚醒，平時都會保持睡眠
	- fsync 執行緒：AOF 緩衝資料重新整理到磁碟
	- close執行緒：檔案關閉
	- 清理回收執行緒：清理物件
- fsync 執行緒、close執行緒、清理回收執行緒是Background I/O (BIO) ，會於背景下執行。


### 版本6.0

> 多執行緒是 Redis6.0 推出的一個新特性。正如上面所說 Redis 是核心執行緒負責網路 IO ，命令處理以及寫資料到緩衝，而隨著網路硬體的效能提升，單個主執行緒處理⽹絡請求的速度跟不上底層⽹絡硬體的速度，導致網路 IO 的處理成為了 Redis 的效能瓶頸。

> 而 Redis6.0 就是從單執行緒處理網路請求到多執行緒處理，通過多個 IO 執行緒並⾏處理網路操作提升例項的整體處理效能。需要注意的是對於讀寫命令，Redis 仍然使⽤單執行緒來處理，這是因為繼續使⽤單執行緒執行命令操作，就不⽤為了保證 Lua 指令碼、事務的原⼦性，額外開發多執行緒互斥機制了。


![](https://i.iter01.com/images/366286b2a68f20c755c2692895d9ff3a58719c78e75a4adf43ae2be2f6841850.png)


> 全部流程分為以下 4 階段：

> **階段一：服務端和客⼾端建立 Socket 連線，並分配處理執行緒**

> 當有客⼾端請求和例項建立 Socket 連線時，主執行緒會建立和客戶端的連線，並把 Socket 放入全域性等待佇列中。然後主執行緒通過輪詢方法把 Socket 連線分配給 IO 執行緒。

> **階段二：IO 執行緒讀取並解析請求**

> 主執行緒把 Socket 分配給 IO 執行緒後，會進⼊阻塞狀態等待 IO 執行緒完成客戶端請求讀取和解析。

> **階段三：主執行緒執⾏請求操作**

> IO 執行緒解析完請求後，主執行緒以單執行緒的⽅式執⾏這些命令操作。

> **階段四：IO 執行緒回寫 Socket 和主執行緒清空全域性隊**

> 主執行緒執行完請求操作後，會把需要返回的結果寫入緩衝區。然後，主執行緒會阻塞等待 IO 執行緒把這些結果回寫到 Socket 中，並返回給客戶端。等到 IO 執行緒回寫 Socket 完畢，主執行緒會清空全域性佇列，等待客戶端的後續請求。

重點：
- Redis 原本是由單個執行緒負責網路請求I/O、指令執行，但由於客戶端本身網路硬體上升級，這會使向Redis發送請求速率增加，使得Redis的單個執行緒難以應付
- 為了解決上述問題，Redis在6.0建立多個執行緒來負責處理客戶端網路I/O請求、並解析需要執行指令是什麼，流程會是：
	- 步驟一：當客戶端與Redis 應用程式建立連線時，會建立彼此對應的Socket連線資訊
	- 步驟二：將Socket連線資訊放入等待佇列
	- 步驟三：主執行緒定期向負責管理I/O多執行緒的模組索要一個I/O執行緒處理，若索要成功的話，該執行緒就從等待佇列取出一個Socket資訊(包含指令)來將對應連線綁定至該I/O執行緒。
	- 步驟四：主執行緒在I/O執行緒執行完畢之前，會保持等待，同時間I/O執行緒會從綁定的Socket接收到對應客戶端的指令，這時會開始解析
	- 步驟五：I/O執行緒解析完並獲取指令，接著將指令傳遞至主執行緒，主執行緒收到就解除等待去執行對應指令
	- 步驟六：主執行緒會將指令執行的執行後結果寫入至緩衝區，
	- 步驟七：主執行緒開始再向負責管理I/O多執行緒的模組索要I/O執行緒來將緩衝區的結果寫回socket，此時主執行緒會保持等待
	- 步驟八：I/O執行緒回寫完成後，就通知主執行緒，主執行緒收到就便解除等待並清空等待佇列，等待下一個請求

![](https://i.iter01.com/images/366286b2a68f20c755c2692895d9ff3a58719c78e75a4adf43ae2be2f6841850.png)

### socket 內容
1. 含有請求內容/回應內容、請求方資訊(IP、域名、Port)、回應方資訊(IP、域名、Port)

## 複習
#🧠 Question :: ->->-> ``

---
Status: 
Tags:
Links:
References:
[[@MianShiGuanWenRedisShiDanZhiXingXuHuanShiDuoZhiXingXu]]
