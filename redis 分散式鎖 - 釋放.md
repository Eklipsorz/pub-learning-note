## 描述

https://zhuanlan.zhihu.com/p/93460690

> ### **释放锁**

> 释放锁的过程就是将原本占有的坑给删除掉，但是也并不能仅仅使用 del key 删除掉就万事大吉了，这样很容易删除掉别人的锁，为什么呢？举一个例子客户端 A 获取到一把 key = name1 的锁（2 秒中），紧接着处理自己的业务逻辑，但是在业务逻辑处理这块阻塞了耗时超过了锁的时间，锁是会自动被释放的，这期间该资源又被客户端 B 获取了 key = name1 的锁，那么客户端 A 在自己的业务处理结束之后直接使用 del key 命令删除会把客户端 B 的锁给释放掉了，所以释放锁的时候要做到仅释放自己占有的锁。

> 加锁的过程中建议把 value 设置为一个随机值，主要是为了更安全的释放锁，在 del key 之前先判断这个 key 存在且 value 等于自己指定的值才执行删除操作。判断和删除不是一个原子性的操作，此处仍需借助 Lua 脚本实现。

```text
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

重點：
- 使用set key 來表示上鎖，但往往key會設定同樣名稱，比如多個請求
```
set key name1
```
- 若是採用同樣名稱的鎖名稱，很有可能釋放鎖的時候，是釋放別人的鎖，比如使用者A使用key=name1上鎖並設定3秒後自動釋放，但業務邏輯處理完之後，就已經過了3秒，所以鎖早已被釋放，且被使用者B使用key=name1來上鎖，這時使用者A若刪除key=name1的話，是刪除使用者B所設定的鎖
- 最佳實踐使用set key來上鎖＋而對應value會是每個使用者專屬的，這樣釋放時才能釋放自己的鎖。


- 另外釋放鎖歸釋放鎖，還得先找到自己的鎖，才能釋放，所以必然有
	- 找鎖
	- 刪除找到的鎖
```
lock = 找鎖
del lock
```
但這兩個指令並不能夠組成一個原子化操作，必須使用lua腳本來實現和redis的指令-EVAL
```
EVAL script
```
## 複習

---
Status: 
Tags:
Links:
References: