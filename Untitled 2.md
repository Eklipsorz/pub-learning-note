## 描述

### webpack 解決了什麼問題
[[@ithomeXunMiWebpack04]] 所描述：
> 當你理解了整個 webpack 的運作流程後，就知道 webpack 已經完美的解決前兩篇文章所提到的問題： **JavaScript 的模組化問題**及**新技術載入的問題**。

重點：
- webpack 主要解決了：
	- JavaScript的模組化問題
	- 新技術載入的問題

### JavaScript 的模組化問題

[[@ithomeXunMiWebpack02]] 所描述的JavaScript 的模組化造成開發困難：
> 由於歷史的原因， JavaScript 的模組化語意有好幾種，由於實作方式及語法都不相同，因此要引用會需要個別處理。如果是自己要開發工具庫讓別人使用的話，也需要分別轉換成不同的模組定義，才能確保使用者不會有引用上的問題發生。

> ES Module 這個原生模組語意的出現，確實讓 JavaScript 的模組化問題出現了一道曙光，但是 JavaScript 的執行環境太過複雜，有前端，有後端，有瀏覽器、Electron、React Native...等不同的環境，各個環境對於 ES Module 的支援度都不一樣，造成使用 ES Module 時還是必須要經過轉換。

> JavaScript 的模組化之路坎坷，確實使得開發變得複雜困難，但是危機就是轉機， Webpack 的發明就完美的解決了這些問題，使前端工程迎來了全面的模組化時代。

重點：
- 模組化問題：
	- 將JS打造成模組的方法過多且混亂，沒有統一的形式：IIFE 模組、AMD、CMD、CommonJS、ES Module
	- 各個平台對於模組載入的支援問題，如瀏覽器對於ES Module的支援度


### 新技術載入的問題
[[@ithomeXunMiWebpack03]] 所描述的新技術載入的問題：
> 網頁技術在現代急遽變化，遇到了各種問題，也出現了許多的解決方案，以下做個總覽：

```
-   JavaScript
    -   宿主環境對各語法支援度不一：Babel
    -   是弱型別語言：TypeScript, flow
-   CSS
    -   宿主環境對各語法支援度不一：PostCSS
    -   語法過於簡單：SASS
    -   是靜態的：CSS in JS
-   HTML
    -   是靜態的：Pug, Template Syntax
```


> 雖然前端工程因為語言的限制產生了許多的問題，但是也都有了對應的方案可以解決，但這些方案都有一個共通的問題，那就是**需要配置相對應的轉譯器才能在瀏覽器上執行**
> 
> 原本這些解決方案的目的是要加速開發的，但每次要執行時都要手動啟動編譯器，反而會降低開發速度，這時候還好有像是 Webpack 這類 bundler 工具的出現，才能順利地將這些工具帶入開發鍊中。

重點：
- 新技術載入的問題都源自於**為了加速開發和解決問題，而提供特定語言體系和編譯器來轉換成能夠讓瀏覽器識別得出來的HTML、JS、CSS**：從特定語言體系的角度來解決問題和開發問題，而非以HTML、JS、CSS本身內容
- 這類型的技術開發時都需要手動啟動編譯才能讓他們從特定語言體系轉換成HTML、JS、CSS，數量越多，就難以管理編譯上的執行


## 複習
#🧠 webpack 主要為了解決以下問題而被提出->->-> `JavaScript的模組化問題、新技術載入的問題`

#🧠 webpack 主要為了解決JavaScript的模組化問題和新技術載入的問題而被提出，那麼JavaScript的模組化問題會是什麼？ ->->-> `將JS打造成模組的方法過多且混亂，沒有統一的形式、各個平台對於模組載入的支援問題`


#🧠 webpack 主要為了解決JavaScript的模組化問題和新技術載入的問題而被提出，那麼新技術載入的問題會是什麼？  ->->-> `新技術載入的問題都源自於**為了加速開發和解決問題，而提供特定語言體系和編譯器來轉換成能夠讓瀏覽器識別得出來的HTML、JS、CSS**：從特定語言體系的角度來解決問題和開發問題，而非以HTML、JS、CSS本身內容，這類型的技術開發時都需要手動啟動編譯才能讓他們從特定語言體系轉換成HTML、JS、CSS，數量越多，就難以管理編譯上的執行`

---
Status: #🌱 
Tags:
[[JavaScript]]
Links:
References:
[[@ithomeXunMiWebpack02]]
[[@ithomeXunMiWebpack03]]
[[@ithomeXunMiWebpack04]]